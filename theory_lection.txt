Сущъность сервера - это может быть железяка, софт; в рамках клиент-серверной архитектуры это может быть сущъность, которая принимает запрос и отвечает на него.
Что значит принимает запрос? Когда есть клиент и есть сервет, и тот кто отправляет запрос это клиент, а кто получает запрос и отвечает это уже сервер. 
Сервер может быть клиентом. Если сервер получает запрос и отдает ответ - вот это он сервер. Но сервер сам может что то спрашивать у других серверов - и в этом случае, в рамках клиент-серверной архитектуры, сервер будет клиентом.
В рамках железа: сервер это может быть какой то шкаф в котором понатыкано всяких железяк, моргают лампочки. Много сервером образуют Дата-центр - это куча серверов и в них крутиться много сервисов, сайтов на которые мы постоянно заходим, т.е. это какие то ограмные дата-центры где эти железяки работают.
Сервером может быть и ваш личный комп или телефон, но только в том случае, эсли на этом сервере запустить программу, которая будет принимать запрос и отправлять ответ. Программки эти называються HTTP-сервер, т.е. это какая то программа, которая работает по протоколу HTTP. Если программа работает по HTTP протоколу,то это значит что программа будет принимать HTTP запрос и отправлять HTTP ответ, в запросы должны быть отправлены с помощью HTTP методов имея все аттрибуты (хэдэры, body или без body, а сервер будет на это отвечать статус-кодом). Это такие правила HTTP. 
Клиентом по сути в рамках клиент-серверной архитектуры может быть тот же сервак, ваш телефон, ваш комп модет быть клиентом, но опять таки на нем должен быть запущен какой то софт который куда-то что-то отправляет. Клиентом может быть и десктопное приложение, например Ворд или игра или онлайн-игра, так вот это у вас на компе десктопно запущена программка, она общаеться с внешним сервером и вот эта програмка является клиентом. 
На вебе что получается, когда вы внури браузера открыли и делаете какие то запросики и браузер отправляет эти запросы на серваки: программка это браузеры (Хром, сафари, опера, мозилла) и они отправляют запросы на серваки, а серваки присылают нам КЛИЕНТЫ, т.е.какой то веб-интерфейс, где мы можем нажать кнопочку, почитать текст, картинку и всё это в удобном виде для человека расположено и вы это все видите/читаете и пользуетесь интерфейсом. 
Двухуровневая клиент-серверная архитектура - это когда есть клиент и сервер.
Трехуровневая клиент-серверная архитектура - это когда клиент, сервер, база данных.
Многоуровневая клиент-серверная архитектура - это когда клиент, сервер, база данных и еще какие то другие сервера, на которые отправляются запросы и прилетают ответы.

РИСУНОК

Клиентом может быть любая железяка или софт который ОТПРАВЛЯЕТ запрос. Нам от клиента больше ничего и не нужно, нужно чтобы он отправил запрос и получил какой то ответ от сервака и грамотно его расположил.
Допустим сайт https://ksendzov.com/loginpage 
где, после / будт loginpage - это называется эндпоинт, т.е. точка касания АПИ сервера, куда полетит HTTP reqvest.
Когда происходит запрос на loginpage, происходит следующее: летит запрос на сервер. На рисунке с сервером есть маленькая прослойка - это будет API (Application Program Interface). Что значит API (Application Program Interface)? Это интерфейс через который вы можете общаться с сервером. К примеру у человека интерфейс это лицо, мы можем быть перед человеком и он нас видит (мы так с ним взаимодействуем), мы можем говорить что то и у него интерфейс ушной, мы можем запахом своим влиять и у него интерфейс нюхательный. Точно так же у серверов: у них есть интерфейс, через который сервер слушает внешний мир. И этого API есть эндроинт (точечки касания). И, допустим, loginpage это один из эндпоинтов (нарисунке в прослойке АПИ маленикие квадратики). 
Вот мы когда нажимаем в браузуре loginpage, летит HTTPS запрос на мой сервер, запрос это reqvest по англ. Когда сервер получил запрос в эндроинт loginpage, это значит, что бэк-энд разработчики написали такое АПИ, в котором есть эндроинт loginpage и если от клиента прилетает Гет-запрос в эндпоинт loginpage, то сервер знает, что делать. Т.е. бэк-энд программисты написали бизнес-логику которая начинает работать если постучаться в конкретно этот эндроинт. Что это значит: мы постучались в loginpage, сервак пошёл на файловую систему, достал нужные картинки, забрал нужные тексты, поднял файлики HTML (Hyper Text Markup Language), поднял файлики CSS (коскадные таблицы стиля чтобы красиво всё грамотно разрисовать). И вот всё что он поднял (картинка, текст, разметку HTML, CSS) это всё ТЕКСТ, даже картинка. Картинка перед тем как полететь по сети на клиент, будет преобразована в текст. Формат преобразования base64 называеться, ну вот такая кодировка: картинка эта перекодируется, картинка это двухмерная матрица с пикселями и цветоразносным показателем цвета пикселя в каждой точке преобразуется вкакой то "абракадабру" текст. Прилетает эта "абракадабра" на клиент и наш браузер знает что с этой "абракадаброй" делать и преобразовывает её обратно в двухмерную матрицу с цветоми вы всё это можете глазами видеть и воспринимать всё что нарисовано на этой картинке. Дальше пакуется вот этот вот ответ нашему клиненту в виде текста и отправляется в виде response. Все что я говорю по поводу "берёт пакует, отправляет картинку, забирает файлик, что то там как то пакует, смотрит" - это бэк-энд программисты пишут вот такую бизнес-логику: какой файлик забрать, какой скрипт запустить который что то соберёт, какую то картинку картинку переконвертить в текст - это прогамисты бэк-ендщики пишут. Это не сразу что то там готовое и какой то умный сервер сразу всё знает. Ничего он не знает. Это бэк-енд програмисты пишут код, который всё вот это делает.
Всё, наш сервак запаковал нам ответ и отправил на клиент. Летит response. 
Прилетел response на наш браузер. Браузер - это такой софт у которого есть ЯДРО БРАУЗЕРА. ЯДРО БРАУЗЕРА - это такая машина, которая распознает и начинает выполнять джава-скрипты, парсит html-ки, короче это такой механизм, в котороый если ты подаеш правильные файли в виде HTML, CSS, JS он их прочитывает, он понимает что с этим нужно делать и делает то что нужно. Как правильно читать html-ку, как правильно отображать стили в каскадной таблице стилей, где расположить картинку, где поставить текст, где поставить какую кнопку на вэб-интерфейсе - это пишут фронт-энд программисты. Т.е. если бэк-эндщики пишут какой файлик взять, какую обработку данных произвести, сходить в базу банных, что то там скомпоновать и отправить на клиент - это делают бэк-эндщики. Фронт-эндщики пишут софт или вэб (в данном случае говорим за вэб) где правильно поставить картинку, правильно отработать какой то скрипт на клиенте, как этот скрипт должен отработать, какие ещё запросики куда отправить в какие сервера (может быть у нас не один сервер а много серверов), где текст какой располодиться, какого цвета будет кнопочка, где будет картинка располагаться чтобы пользователю было удобно всё читать - это пишут фронт-энд программисты. Так вот у нас на клиент прилетает пакет ответов. Ядро браузера берет это пакет и начинает смотреть, что html это скелет, что картинка будет стоять вверху, текст будет стоять чуть правее от картинки, под текстом будет какая то кнопочка и т.д. CSS - это мясо т.е. какого цвета будет кнопка (красная, зеленая, с заливкой), текст будет жирным/не жирным.И в html можно делать стили и картинки, но как бы если по взрослому писать прод, то там все на CSS+на JS. Т.е. какого размера картинка, левее/правее она станет, кнопочка какого цвета будет, это каскадная таблица CSS. 
И как это всё будет работать? Расположить мы расположили, скелет, картинки всё мы сделали. Но чтобы это всё ещё работало, т.е.кнопка нажималась и отправлялся запрос, если какая то механика внутри чтобы выпал список, какие то фильтры в интернет-магазине вы ставите и отправляете запрос на сервер - вот вся механика действия этого скелета и мяса - это JS, это делают фронт-энд разработчики. Так вот, пришёл пакет от сервера и там у нас форма логина. Что делает наш клиент? Клиент ставит поле логин и пароль (на картинке Client появились поля) и будет кнопка внизу Sing In (это плейсхолдеры). Итак, пользователь увидел что html и css всё расставили правильно, браузер всё это отобразил понятно для человека и пользователь понимает куда надо ввести логин, а куда пароль, а куда нажать чтобы залогиниться. Так вот, когда пользователь нажимет на кнопку, происходит следующая механика: отправляется HTTP запрос в ендпоинт login(на картинке появляються нижние стрелочки с https://ksendzov/login). Т.е. у нас в эндпоинт login отправляется запрос методом POST в котором будет следующее: отправляеться запрос на сервак, у этого запроса есть боди, потому что запрос летит методом POST и у метода POST есть боди и в этом боди будет лежать логин и пароль и лежать они будут скорее всего в виде JSON. Эта JSON пакуется клиентом, т.е. на JS фронт-энд програмисты написали такой скрипт, который в боди запроса положит JSON в которой будет логин и пароль. И фронт-энд программисты ещё написали на какой энд-поинт полетит reqvest (они договорились с бэк-энд програмистами, что типа "ребята, у нас с этоц кнопочки будет лететь запрос, дайте назнание эндпоинта на который нам слать запрос чтобы пользователь передав свои логин и пароль смог залогинится". Договорились что эндпоинт будет называться логин и на кнопочке програмисты поставили "логин"). А бэк-энд програмисты опять же написали бизнес-логику по этому эндпоинту, что когда прилетает запрос по эндпоинту "логин" мы знаем, что надо пойти в запрос, в боди запроса достать оттуда логин и достать оттуда пароль и могут на серваке ещё накрутить какую то валидацию, чтобы невозможно было что то плохое положить на сервак. Могут накрутить валидацию, а могут не накрутить. Сервер берёт логин и идет в базу данных(на картинку появляеться BD). Сервер спрашивает у базы SQL запросом "база, скажи, у тебя такой то пользователь существует?". База пошла, посмотрела "ну есть такой человек" - мы его ИДЕНТИФИЦИРОВАЛИ по логину. Далее сервер спрашивает "база, а давай мы этого пользователя аутентифицируем, сделаем АУТЕНТИФИКАЦИЮ", база говорит "хорошо", мы спрашиваем "пароль вот такой, посмотри?", база говорит "да, пароль такой". Ок, пользователь АУТЕНТИФИЦИРОВАН. 
Поскольку мы пользователя идентифицировали, потом аутентифицировали, его можно авторизовать. Т.е. мы смотрим, что у нас этот вот "Вадим" пароль у него "Валим123" и у этого Вадима права только на свой личный кабинет и свои личные данные. Значит, сервер такой "если у него права только на личные данные, давай ка его личные данные" т.е. если у нас это клиент-банк - то это история транзакций по карточке, какието выписки, номера карточек, вот лично его данные. База ему это всё возвращает, наш сервер это все собирает эти запросы и информацию и пакует пакует пакует, запаковал и такой "ну всё, пакет данных есть, вот мы еще JSONочку какую то подставим, засунули в JSONочку запаковали это всё дело, html, css, JS и отдаём клиенту личную страницу позьзователя". Т.е. мы собрали всю информацию, собрали каконо будет выглядеть и отдаём клиенту - получается ответ сервера. Нам на клиент прилетает ответ сервака и мы видим фотографию если мы ее вставляли, вот список карточек, вот история транзакций по этой карточке, а вот здесь мы можем нажать кнопку "пополнить моб.телефон" и опять же: нажал кнопочку, отправил какой то запрос на сервак, сервак ответил каким то ответом (интерфейсом где ты можеш внести количество денег и нажать кнопочку "оплатить"). НО нажатие любой кнопки на клиенте это не значит отправка какого то запроса на сервак. Нет. Как напишут фронт-энд програмисты так и будет работать. Возможно, нажатие на кнопочку, это просто сработка какого то джава скрипта. И напишет фронт-энд програмист скрипт который отправляет запрос на сервер - запрос отправится, напишет програмист, что при нажатии на кнопку у нас картинка ниже съезжает - значит картинка съезжает ниже при нажатии на кнопку. Что такое ивенты в джава скрипте и как они отрабатываются это ещё отдельно с вами мы посмотрим, когда будем тестировать поля.
Собственно так и работает клиент-серверная архитектура HTTP. 
Помните, когда я говорил про многоуровневую клиент-серверную архитектуру, так вот что значит многоуровневая - это значит, что наш сервер тоже может быть клиентом и он может отправлять запросы на какой то другой сервер. Предположим, у нас какой то человек логинится, и мы перед тем как дать ему личные данные, отправляем запрос в МВД (на сервера МВД) где запрашиваем данные по судимости, ести ли у него разрешение пользоваться деньгами или нет. Я помню я работал в канторе Софт-клую которая пилит в Минске софт для банка. Я тестировал бизнес-логику, где сервер банка отправляет запрос в МВД, а робот МВД отвечает про судимости, если судимости нет, то отвечает всей информацией, если судимость есть, то отдать пользователю галочку что есть судимость и из вас взымается какие то деньги с вашего счета. Т.е. сервер автоматически что то запрашивает у другого сервака. Тоже по HTTP, у этого сервака тоже есть какая то APIшка, наш сервер в эту APIшку что то спрашивает, это тот же HTTP-запрос, ему по HTTP протоколу тоже другой сервак МВДшный отвечает. Происходит ровно та же логика как с клиентом нашим который я вот рассказывал. Вот жто тоже какой то сервак МВД, у него тоже есть своя АПИшка и наш сервак в него тоже стучится и ему что то отвечают какие то ответы. Вне зависимости от того, что получил наш сервер по этому внешнему серверу, дальше уже какая то другая бизнес-логика идет.

Микросервисная архитектура. На картинке мы рассматривали 1 серваи и база данных - вот это монолит, это монолитная архитектура. Когда у тебя появляются другие серваки, т.е. 1 сервер логинит пользователя в базу, другой сервер что то валидирует, третий сервер берет откуда то картинки, червертый сервер собирает  какую то статичтику по пользователю. Вот когда функции разбиты по нескольким серверам, вот это микросервисная архитектура, и вот эти сервачки со своими АПИшками называются микросервисы или веб-сервисы. Если програмисты запилят иерархию какой сервер за каким отправляет запрос, то так и будет.

